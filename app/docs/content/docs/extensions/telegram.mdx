---
title: Telegram Extension
description: Complete guide to integrating Axiomkit agents with Telegram bots
---

# Telegram Extension

## Overview

The Telegram extension enables Axiomkit agents to function as intelligent Telegram bots with message handling, inline keyboards, file sharing, and group management capabilities.

## Features

- **Message Handling**: Process text messages, photos, documents, and voice messages
- **Inline Keyboards**: Create interactive button interfaces
- **File Sharing**: Send and receive files, images, and media
- **Group Management**: Handle group chats and channel messages
- **Webhook & Polling**: Support for both webhook and polling modes
- **Callback Queries**: Handle button clicks and inline interactions

## Installation

```bash
pnpm add @axiomkit/telegram telegraf
```

## Quick Start

```typescript
import { createAgent } from "@axiomkit/core";
import { telegram } from "@axiomkit/telegram";
import { groq } from "@ai-sdk/groq";

const agent = createAgent({
  model: groq("gemma2-9b-it"),
  extensions: [telegram],
});

await agent.start();
```

## Configuration

### Environment Variables

```bash
# Required
TELEGRAM_BOT_TOKEN=your_telegram_bot_token

# Optional
TELEGRAM_WEBHOOK_URL=https://your-domain.com/webhook  # For webhook mode
TELEGRAM_POLLING=true                                 # Enable polling mode
```

### Bot Setup

1. **Create Telegram Bot**
   - Message [@BotFather](https://t.me/botfather) on Telegram
   - Use `/newbot` command to create a new bot
   - Choose a name and username for your bot
   - Copy the bot token provided

2. **Configure Bot Settings**
   ```typescript
   const telegramExtension = telegram({
     // Bot configuration
     botToken: process.env.TELEGRAM_BOT_TOKEN,
     
     // Webhook configuration (optional)
     webhook: {
       url: process.env.TELEGRAM_WEBHOOK_URL,
       port: 3000,
     },
     
     // Polling configuration (optional)
     polling: {
       enabled: true,
       interval: 1000,
     },
   });
   ```

3. **Set Bot Commands**
   ```typescript
   // Set bot commands via BotFather or programmatically
   const botCommands = [
     { command: "start", description: "Start the bot" },
     { command: "help", description: "Show help information" },
     { command: "weather", description: "Get weather information" },
   ];
   ```

## Usage Examples

### Basic Message Handling

```typescript
import { telegram, telegramContext } from "@axiomkit/telegram";

const customTelegramContext = telegramContext({
  instructions: [
    "You are a helpful Telegram bot assistant.",
    "Respond to user messages in a friendly manner.",
    "Use Telegram markdown formatting when appropriate.",
  ],
});

const agent = createAgent({
  model: groq("gemma2-9b-it"),
  extensions: [
    telegram({
      contexts: {
        telegram: customTelegramContext,
      },
    }),
  ],
});
```

### Custom Commands

```typescript
import { action } from "@axiomkit/core";
import { z } from "zod";

const weatherCommand = action({
  name: "weather",
  description: "Get weather information for a location",
  schema: z.object({
    location: z.string().describe("City or location name"),
  }),
  handler: async (args, ctx, agent) => {
    const { location } = args;
    
    // Call weather API
    const weather = await getWeather(location);
    
    return {
      text: `ðŸŒ¤ï¸ Weather in ${location}:\n\n` +
            `Temperature: ${weather.temperature}Â°C\n` +
            `Condition: ${weather.condition}\n` +
            `Humidity: ${weather.humidity}%\n` +
            `Wind: ${weather.windSpeed} km/h`,
      parse_mode: "Markdown",
    };
  },
});

const agent = createAgent({
  model: groq("gemma2-9b-it"),
  extensions: [
    telegram({
      actions: [weatherCommand],
    }),
  ],
});
```

### Inline Keyboards

```typescript
const menuCommand = action({
  name: "menu",
  description: "Show main menu with options",
  handler: async (args, ctx, agent) => {
    return {
      text: "Welcome! Choose an option:",
      reply_markup: {
        inline_keyboard: [
          [
            { text: "ðŸŒ¤ï¸ Weather", callback_data: "weather" },
            { text: "ðŸ“° News", callback_data: "news" },
          ],
          [
            { text: "ðŸŽµ Music", callback_data: "music" },
            { text: "ðŸŽ® Games", callback_data: "games" },
          ],
          [
            { text: "â“ Help", callback_data: "help" },
          ],
        ],
      },
    };
  },
});

const callbackHandler = action({
  name: "handle-callback",
  description: "Handle inline keyboard callbacks",
  schema: z.object({
    callback_data: z.string(),
    user_id: z.number(),
  }),
  handler: async (args, ctx, agent) => {
    const { callback_data, user_id } = args;
    
    switch (callback_data) {
      case "weather":
        return {
          text: "Enter a city name to get weather information:",
          reply_markup: {
            keyboard: [["Cancel"]],
            resize_keyboard: true,
            one_time_keyboard: true,
          },
        };
      
      case "news":
        return {
          text: "ðŸ“° Latest news:\n\n" +
                "â€¢ Breaking news item 1\n" +
                "â€¢ Breaking news item 2\n" +
                "â€¢ Breaking news item 3",
        };
      
      case "help":
        return {
          text: "ðŸ¤– Bot Commands:\n\n" +
                "/start - Start the bot\n" +
                "/menu - Show main menu\n" +
                "/weather <city> - Get weather\n" +
                "/help - Show this help",
        };
      
      default:
        return {
          text: "Unknown option selected.",
        };
    }
  },
});
```

### File Handling

```typescript
const fileHandler = action({
  name: "handle-file",
  description: "Handle file uploads and downloads",
  schema: z.object({
    file_id: z.string(),
    file_name: z.string().optional(),
    mime_type: z.string().optional(),
  }),
  handler: async (args, ctx, agent) => {
    const { file_id, file_name, mime_type } = args;
    
    // Process different file types
    if (mime_type?.startsWith("image/")) {
      return {
        text: `ðŸ“¸ Image received: ${file_name}`,
        caption: "I've received your image!",
      };
    } else if (mime_type?.startsWith("video/")) {
      return {
        text: `ðŸŽ¥ Video received: ${file_name}`,
        caption: "I've received your video!",
      };
    } else if (mime_type === "application/pdf") {
      return {
        text: `ðŸ“„ PDF document received: ${file_name}`,
        caption: "I've received your PDF document!",
      };
    } else {
      return {
        text: `ðŸ“Ž File received: ${file_name || "Unknown file"}`,
        caption: "I've received your file!",
      };
    }
  },
});
```

## Advanced Configuration

### Custom Telegram Context

```typescript
import { context } from "@axiomkit/core";
import { z } from "zod";

const customTelegramContext = context({
  type: "telegram-chat",
  schema: z.object({
    chatId: z.number(),
    userId: z.number().optional(),
  }),
  key: ({ chatId, userId }) => `${chatId}:${userId || "group"}`,
  create: (state) => ({
    messages: [],
    userPreferences: {},
    chatSettings: {
      language: "en",
      notifications: true,
      autoReply: false,
    },
  }),
  render: ({ memory, state }) => `
    Telegram Chat Context:
    Chat ID: ${state.chatId}
    User ID: ${state.userId || "Group chat"}
    Messages: ${memory.messages.length}
    Language: ${memory.chatSettings.language}
  `,
});
```

### Message Filtering

```typescript
const telegramExtension = telegram({
  messageFilters: {
    // Only respond to specific chat types
    allowedChatTypes: ["private", "group", "supergroup"],
    
    // Ignore messages from bots
    ignoreBots: true,
    
    // Custom filter function
    customFilter: (message) => {
      // Only respond to messages in private chats or group commands
      return message.chat.type === "private" || 
             message.text?.startsWith("/");
    },
  },
});
```

### Rate Limiting

```typescript
const telegramExtension = telegram({
  rateLimits: {
    messagesPerMinute: 20,
    commandsPerMinute: 10,
    cooldownMs: 500,
  },
});
```

## Event Handling

### Message Events

```typescript
const messageHandler = action({
  name: "handle-telegram-message",
  description: "Handle incoming Telegram messages",
  handler: async (args, ctx, agent) => {
    const { message, chat, from } = args;
    
    // Log message
    console.log(`${from?.first_name}: ${message.text}`);
    
    // Update chat memory
    ctx.agentMemory.messages.push({
      text: message.text,
      timestamp: new Date(),
      user: from?.first_name,
    });
    
    // Process message content
    if (message.text?.toLowerCase().includes("hello")) {
      return {
        text: `Hello ${from?.first_name}! ðŸ‘‹\nHow can I help you today?`,
      };
    }
    
    return null; // No response
  },
});
```

### Callback Query Events

```typescript
const callbackQueryHandler = action({
  name: "handle-callback-query",
  description: "Handle inline keyboard callbacks",
  handler: async (args, ctx, agent) => {
    const { callback_query } = args;
    const { data, from, message } = callback_query;
    
    // Answer callback query to remove loading state
    await ctx.answerCallbackQuery({
      callback_query_id: callback_query.id,
    });
    
    // Process callback data
    if (data === "confirm") {
      return {
        text: "âœ… Action confirmed!",
        chat_id: message?.chat.id,
        message_id: message?.message_id,
        reply_markup: { inline_keyboard: [] }, // Remove keyboard
      };
    }
    
    return null;
  },
});
```

## Error Handling

```typescript
const robustTelegramExtension = telegram({
  errorHandling: {
    // Retry failed operations
    retryAttempts: 3,
    retryDelay: 1000,
    
    // Log errors
    logErrors: true,
    
    // Custom error handler
    onError: (error, context) => {
      console.error("Telegram error:", error);
      
      // Send error notification to user
      if (context.chat?.id) {
        context.sendMessage({
          chat_id: context.chat.id,
          text: "âŒ An error occurred while processing your request. Please try again.",
        });
      }
    },
  },
});
```

## Best Practices

### 1. **User Experience**
```typescript
// Provide clear feedback
const userFriendlyResponse = {
  text: "âœ… Your request has been processed successfully!\n\n" +
        "ðŸ“Š Summary:\n" +
        "â€¢ Item 1: Completed\n" +
        "â€¢ Item 2: In progress\n" +
        "â€¢ Item 3: Pending\n\n" +
        "Need anything else?",
  parse_mode: "Markdown",
  reply_markup: {
    inline_keyboard: [
      [{ text: "ðŸ”„ Refresh", callback_data: "refresh" }],
      [{ text: "â“ Help", callback_data: "help" }],
    ],
  },
};
```

### 2. **Message Formatting**
```typescript
// Use Telegram markdown formatting
const formattedMessage = {
  text: "*Bold Title*\n\n" +
        "_Italic subtitle_\n\n" +
        "`Code example`\n\n" +
        "[Link text](https://example.com)\n\n" +
        "```\nCode block\n```",
  parse_mode: "MarkdownV2",
};
```

### 3. **State Management**
```typescript
// Maintain user state in context memory
const userContext = context({
  type: "telegram-user",
  create: (state) => ({
    currentState: "idle",
    conversationHistory: [],
    preferences: {
      language: "en",
      timezone: "UTC",
      notifications: true,
    },
    activeCommands: new Map(),
  }),
});
```

## Troubleshooting

### Common Issues

1. **Bot Not Responding**
   - Check bot token and permissions
   - Verify webhook URL (if using webhooks)
   - Ensure polling is enabled (if using polling)

2. **Commands Not Working**
   - Register commands with BotFather
   - Check command permissions
   - Verify command structure

3. **Webhook Issues**
   - Ensure HTTPS is enabled
   - Check webhook URL accessibility
   - Verify SSL certificate

### Debug Mode

```typescript
const debugTelegramExtension = telegram({
  debug: true,
  logLevel: "debug",
  verbose: true,
});
```

### Testing

```typescript
// Test bot functionality
describe("Telegram Bot", () => {
  it("should handle start command", async () => {
    const agent = createAgent({
      model: mockModel,
      extensions: [telegramExtension],
    });
    
    const result = await agent.run({
      context: telegramContext,
      args: { chatId: 123456, userId: 789012 },
      input: "/start",
    });
    
    expect(result).toBeDefined();
  });
});
```

This comprehensive Telegram integration enables Axiomkit agents to provide rich, interactive experiences within Telegram chats while maintaining the framework's core capabilities.
